# Hammock

[![Build Status](https://travis-ci.org/pepegar/hammock.svg?branch=master)](https://travis-ci.org/pepegar/hammock)
[ ![Download](https://api.bintray.com/packages/pepegar/com.pepegar/hammock-core/images/download.svg) ](https://bintray.com/pepegar/com.pepegar/hammock-core/_latestVersion) 

Hammock is yet another HTTP client for Scala.  Under the hood it's a purely functional wrapper over [Apache Http Commons][httpcommons] for JVM and [XmlHTTPRequest][xhr] for JS.

## Installation

Add the following to your `build.sbt`.

```scala
resolvers += Resolver.bintrayRepo("pepegar", "com.pepegar")

// For Scala 2.11 or 2.12
libraryDependencies += "com.pepegar" %% "hammock" % "0.1"

// For ScalaJS
libraryDependencies += "com.pepegar" %%% "hammock" % "0.1"
```


Hammock tries to differentiate from other libraries with the following:

1. It's easy to use, has a high level API
2. ~~It's library agnostic~~ Will be library agnostic, current implementation is [cats][cats]-based.
3. It's typeful, tries to represent effects at type level.
4. It follows the _Bring Your Own Concurrency Monad_ pattern.
5. It has good documentation.

[httpcommons]: http://hc.apache.org/
[xhr]: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
[cats]: http://typelevel.org/cats

## How does Hammock look in action?

```scala
import cats._
import cats.implicits._
import scala.util.{ Failure, Success, Try }
import io.circe._
import io.circe.generic.auto._
import hammock._
import hammock.implicits._
import hammock.circe.implicits._


object HttpClient {
  val response = Hammock
    .request(Method.GET, "https://api.fidesmo.com/apps", Map()) // In the `request` method, you describe your HTTP request
    .run[Try]
    .as[List[String]]
}
```

